
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE SCHEMA IF NOT EXISTS "public";

ALTER SCHEMA "public" OWNER TO "pg_database_owner";

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."drink_reviews" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "drink_id" bigint NOT NULL,
    "user_id" uuid NOT NULL,
    "score" integer NOT NULL,
    "message" text
);

ALTER TABLE "public"."drink_reviews" OWNER TO "postgres";

ALTER TABLE "public"."drink_reviews" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."drink_review_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."drinks" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "name" text DEFAULT '""'::text NOT NULL,
    "producer" bigint,
    "description" text DEFAULT '""'::text NOT NULL,
    "user_id" uuid,
    "href" text,
    "fts" tsvector GENERATED ALWAYS AS (to_tsvector('english'::regconfig, ((description || ' '::text) || name))) STORED,
    "image" bigint
);

ALTER TABLE "public"."drinks" OWNER TO "postgres";

ALTER TABLE "public"."drinks" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."drinks_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."images" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "url" character varying,
    "storage_vendor" character varying NOT NULL,
    "user" uuid NOT NULL
);

ALTER TABLE "public"."images" OWNER TO "postgres";

ALTER TABLE "public"."images" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."images_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."producers" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "name" text,
    "website" text
);

ALTER TABLE "public"."producers" OWNER TO "postgres";

ALTER TABLE "public"."producers" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."producers_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "user_id" uuid NOT NULL,
    "name" text,
    "profile_picture" bigint
);

ALTER TABLE "public"."user_profiles" OWNER TO "postgres";

ALTER TABLE "public"."user_profiles" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_profiles_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

ALTER TABLE ONLY "public"."drink_reviews"
    ADD CONSTRAINT "drink_review_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."drinks"
    ADD CONSTRAINT "drinks_href_key" UNIQUE ("href");

ALTER TABLE ONLY "public"."drinks"
    ADD CONSTRAINT "drinks_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_url_key" UNIQUE ("url");

ALTER TABLE ONLY "public"."producers"
    ADD CONSTRAINT "producers_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_key" UNIQUE ("user_id");

CREATE INDEX drink_fts ON public.drinks USING gin (fts);

CREATE INDEX href_index ON public.drinks USING btree (href);

CREATE INDEX idx_drink_name ON public.drinks USING btree (name);

CREATE INDEX pgweb_idx_drinks_name ON public.drinks USING gin (to_tsvector('english'::regconfig, name));

CREATE UNIQUE INDEX unique_drink_user ON public.drink_reviews USING btree (drink_id, user_id);

ALTER TABLE ONLY "public"."drink_reviews"
    ADD CONSTRAINT "drink_reviews_drink_id_fkey" FOREIGN KEY (drink_id) REFERENCES public.drinks(id);

ALTER TABLE ONLY "public"."drink_reviews"
    ADD CONSTRAINT "drink_reviews_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE ONLY "public"."drinks"
    ADD CONSTRAINT "drinks_image_fkey" FOREIGN KEY (image) REFERENCES public.images(id);

ALTER TABLE ONLY "public"."drinks"
    ADD CONSTRAINT "drinks_producer_fkey" FOREIGN KEY (producer) REFERENCES public.producers(id);

ALTER TABLE ONLY "public"."drinks"
    ADD CONSTRAINT "drinks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE;

ALTER TABLE ONLY "public"."images"
    ADD CONSTRAINT "images_user_fkey" FOREIGN KEY ("user") REFERENCES auth.users(id) ON UPDATE CASCADE;

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_profile_picture_fkey" FOREIGN KEY (profile_picture) REFERENCES public.images(id) ON UPDATE CASCADE ON DELETE SET NULL;

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE;

CREATE POLICY "Enable delete for users based on user_id" ON "public"."drink_reviews" FOR DELETE USING ((auth.uid() = user_id));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."drink_reviews" FOR INSERT TO authenticated WITH CHECK (true);

CREATE POLICY "Enable insert for authenticated users only" ON "public"."drinks" FOR INSERT TO authenticated WITH CHECK ((auth.uid() = user_id));

CREATE POLICY "Enable insert for authenticated users only" ON "public"."images" FOR INSERT TO authenticated WITH CHECK (true);

CREATE POLICY "Enable insert for users based on user_id" ON "public"."user_profiles" FOR INSERT WITH CHECK (true);

CREATE POLICY "Enable read access for all users" ON "public"."drink_reviews" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."drinks" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."images" FOR SELECT USING (true);

CREATE POLICY "Enable read access for all users" ON "public"."producers" FOR SELECT USING (true);

CREATE POLICY "Enable update for users own reviews" ON "public"."drink_reviews" FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));

CREATE POLICY "Select only for your own profiles" ON "public"."user_profiles" FOR SELECT TO authenticated USING ((auth.uid() = user_id));

CREATE POLICY "Update only owner of drink" ON "public"."drinks" FOR UPDATE TO authenticated USING ((auth.uid() = user_id)) WITH CHECK ((auth.uid() = user_id));

ALTER TABLE "public"."drink_reviews" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."drinks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."images" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."producers" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON TABLE "public"."drink_reviews" TO "anon";
GRANT ALL ON TABLE "public"."drink_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."drink_reviews" TO "service_role";

GRANT ALL ON SEQUENCE "public"."drink_review_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."drink_review_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."drink_review_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."drinks" TO "anon";
GRANT ALL ON TABLE "public"."drinks" TO "authenticated";
GRANT ALL ON TABLE "public"."drinks" TO "service_role";

GRANT ALL ON SEQUENCE "public"."drinks_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."drinks_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."drinks_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."images" TO "anon";
GRANT ALL ON TABLE "public"."images" TO "authenticated";
GRANT ALL ON TABLE "public"."images" TO "service_role";

GRANT ALL ON SEQUENCE "public"."images_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."images_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."images_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."producers" TO "anon";
GRANT ALL ON TABLE "public"."producers" TO "authenticated";
GRANT ALL ON TABLE "public"."producers" TO "service_role";

GRANT ALL ON SEQUENCE "public"."producers_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."producers_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."producers_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."user_profiles" TO "anon";
GRANT ALL ON TABLE "public"."user_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";

GRANT ALL ON SEQUENCE "public"."user_profiles_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_profiles_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_profiles_id_seq" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";

RESET ALL;
